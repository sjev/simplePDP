# 
# How it works
# ---------------
#
# decomposition is a tree starting from a single requirement and decomposing them into
# multiple requirements, until a requirement can be tranformed into design choice
# 
#  Workflow
# ----------
#  * start from the root requirement and decompose further, example below.
#    supported objects
#     - requrements = a list with separate requirements  
#     - decomposition = rationale on how to split to multiple requirements
#  * separate decomposition trees are separated by `---` separators
#  * extra files can be included with !include directive


# this is the TOP LEVEL requirement, everything should trace back to this one.
ROOT: |
  A user (architect or designer) **needs** to manage requirements of a complex system.
  A good requirement management system has a set of high-level requirements
  
requirements:
  
  R1: 
    req: tool **must** support requirement workflow
    decomposition:  |
      typical workflow consists of setting status to 'draft/reviewed/confirmed' or similar.
      requirements have a certain type, for example 'functional' or 'unit'
    requirements:
      R1.1: 
        req : each requirement **must** have a status
       
      R1.2: 
        req : each requirement **must** have a unique identifier
        solution: S004
      
  R2 : 
    req: tool **must** have requirement traceability
    decomposition: every requirement **must** be traceable up to the origin and down to the solution
    requirements:
      R2.1 : dummy requirement
      
  R3 : 
    req: tool **must** have version control
    solution: S003
    
  R4 : 
    req: tool **must** support multiple users
    solution: S003
  R5 : 
    req : tool **must** be user-friendly and support "traditional" way of writing requrements.
    decomposition: !include userFriendly.yml
  
  R6: 
    req: tool **must** generate requirement documents 
    requirements:
      R6.1: tool **must** produce html output
      R6.2: tool **should** produce pdf
    
# this section describes found solutions. These don't need to be cascading.
solutions:
  S001 : |
      each requirment has a default status, being 'draft'. A new status can be defined with
      keyword 'status'
  S002 : by using yaml data format, the user is encouraged to store data in a structured way
  S003 : | 
    by using plain text files and *git* version control, keeping track of changes is provided out of the box.
    git tags can be used for baselining the system.
  S004 : | 
    each requirement is assigned a unique key by the user. When extracting requirements, these
    will be sorted by their keys
  