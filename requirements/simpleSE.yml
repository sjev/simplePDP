# 
# How it works
# ---------------
#
# decomposition is a tree starting from a single requirement and decomposing them into
# multiple requirements, until a requirement can be tranformed into design choice
# 
#  Workflow
# ----------
#  * start from the root requirement and decompose further, example below.
#    supported objects
#     - requrements = a list with separate requirements  
#     - decomposition = rationale on how to split to multiple requirements
#  * separate decomposition trees are separated by `---` separators
#  * extra files can be included with !include directive


# this is the TOP LEVEL requirement, everything should trace back to this one.
ROOT: | 
  To manage a coplex system design and validation, top-level requirements need
  to be decomposed to low level unit requirements. Each requirement should have a 
  design solution and validation.
  
requirements:
  
  R001:
    req : Requirements **must** be documented in a consistent, structural way.
    rationale : |
      A user (architect or designer) **needs** to manage requirements of a complex system.
      A good requirement management system has a set of high-level requirements
  
    requirements:
      
      R002:
        req: tool **must** support requirement workflow
        rationale : | 
          requirements are defined and changed during development process.
          Usually a requirement goes through different stages from 
        requirements:
          R003: 
            req : each requirement **must** have a status
            rationale : "typical workflow consists of setting status to 'draft/reviewed/confirmed' or similar."
          R004:
            req : each requirement **must** have a unique identifier
            rationale : "needed to link requirements"
            solution: S004
            
          R004a:
            req : tool **must** check identifiers for consistency
            rationale : "because identifiers are entered by hand, there is a chance of duplicate entries. these are not allowed"
            related: R008d
            
              
      R006:
        req: tool **must** have version control
        solution: S003
        
      R007:
        req: tool **must** support multiple users
        solution: S003
      
        # here is an example on how to include a separate file
      R008: !include userFriendly.yml
      
      R009:
        req: tool **must** generate requirement documents 
        requirements:
          R009a:  {req: tool **must** produce html output}
          R009b:  {req: tool **should** produce pdf}
      
      R010:
        req: tool **must** have requirement traceability
        rationale: every requirement **must** be traceable up to the origin and down to the solution
        # TODO: decompose further

# this section describes found solutions. These don't need to be cascading.
solutions:
  S001 : |
      each requirment has a default status, being 'draft'. A new status can be defined with
      keyword 'status'
  S002 : by using yaml data format, the user is encouraged to store data in a structured way
  S003 : | 
    by using plain text files and *git* version control, keeping track of changes is provided out of the box.
    git tags can be used for baselining the system.
  S004 : | 
    each requirement is assigned a unique key by the user. When extracting requirements, these
    will be sorted by their keys. This is unfortunately more labor-intensive than autonumbering,
    but ensures that requirement identifiers are consistent between baselines and intermediate
    versions.
  
  